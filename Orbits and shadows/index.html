<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Im causing problems on purpose</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform float time;
			uniform vec2 resolution;
			varying vec2 fragUV;
			varying vec3 fragNormal;
			void main() {
			  vec3 lightPos=vec3(0.,2.,0.);
			  lightPos=lightPos/length(lightPos);
			}
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			uniform float time;
			uniform vec2 resolution;
			varying vec2 fragUV;
			varying vec3 fragNormal;
            void main() {
			  fragUV=uv;
			  vec4 newNormal=modelMatrix*vec4(normal,0.0);
			  fragNormal=newNormal.xyz;
			  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );
			}
		</script>
		<script type="module">

			import * as THREE from './files/three.js';
			import { OrbitControls } from './files/OrbitControls.js';

			let camera, scene, renderer;
			let meshs;
			let mesh3;
			let mesh4;
			let t=0;

		

			function init() {

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.z = 2;


				scene = new THREE.Scene();

				const texture = new THREE.MeshBasicMaterial({color:0xff00ff});
				texture.colorSpace = THREE.SRGBColorSpace;

				const geometry = new THREE.SphereGeometry( 20, 50, 50 );
				const geometry2 = new THREE.SphereGeometry(3, 50, 50 ); 
				const material2 = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
				const moon = new THREE.SphereGeometry(2,25,25);
				const moon_material = new THREE.MeshBasicMaterial({color: 0xff0000})
				

				let uniforms1 = {
                            time:       { value: 1.0 },
                            resolution: { value: new THREE.Vector2() }
                        };

				var material = new THREE.ShaderMaterial( {
					uniforms: uniforms1,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
					} );

				meshs=new Array();

				let mesh = new THREE.Mesh( geometry, material2 );
				mesh.position.set(0,0,0);
			    scene.add( mesh );
				meshs.push(mesh);

				mesh3 = new THREE.Mesh(geometry2,texture);
				scene.add(mesh3);
				mesh4 = new THREE.Mesh(moon,moon_material);
				scene.add(mesh4);

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				const controls = new OrbitControls( camera, renderer.domElement );
				camera.position.set( 0, 20, 60 );
				controls.update();

				window.addEventListener( 'resize', onWindowResize );
			}

			init();

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			let angle = 0;
			const radius = 23;
			const speed = 0.0001;
			function animate() {
				requestAnimationFrame(animate);
				meshs.forEach((mesh)=>{  // anonymous function using fat arrow
					mesh.rotation.x += 0.004;
				});
				angle += speed;
				mesh3.position.x = radius * Math.cos(angle);
				mesh3.position.z = radius * Math.sin(angle);
				mesh3.position.y = radius * Math.cos(angle);
				mesh4.position.x = (radius+4) * (Math.cos(angle/2));
				mesh4.position.z = (radius+4) * (Math.sin(angle/2));

				renderer.render( scene, camera );
			}
			

		</script>

	</body>
</html>
